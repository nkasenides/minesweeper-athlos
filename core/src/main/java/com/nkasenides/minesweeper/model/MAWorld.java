/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 20-11-2021 09:37:16
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package com.nkasenides.minesweeper.model;

import java.util.ArrayList;
import java.util.List;
import com.nkasenides.athlos.proto.Transmittable;
import com.nkasenides.athlos.proto.GenericTransmittable;
import com.nkasenides.minesweeper.proto.*;
import com.nkasenides.athlos.model.*;

public class MAWorld implements IGrid4World, Transmittable<MAWorldProto.Builder> {

    public static final WorldType type = WorldType.TILE_HEX;

    private int maxPlayers;    
    private long seed;    
    private ArrayList<String> chunkIDs = new ArrayList<>();    
    private String ownerID;    
    private long createdOn;    
    private Difficulty difficulty;    
    private long maxRows;    
    private int heightLimit;    
    private String name;    
    private String id;    
    private GameState state;    
    private long maxCols;    
    private ArrayList<String> subscribedSessionIDs = new ArrayList<>();    

    public int getMaxPlayers() {    
        return maxPlayers;        
    }    
    
    public long getSeed() {    
        return seed;        
    }    
    
    public List<String> getChunkIDs() {
        return chunkIDs;        
    }    
    
    public String getOwnerID() {    
        return ownerID;        
    }    
    
    public long getCreatedOn() {    
        return createdOn;        
    }    
    
    public Difficulty getDifficulty() {    
        return difficulty;        
    }    
    
    public long getMaxRows() {    
        return maxRows;        
    }    
    
    public int getHeightLimit() {    
        return heightLimit;        
    }    
    
    public String getName() {    
        return name;        
    }    
    
    public String getId() {    
        return id;        
    }    
    
    public GameState getState() {    
        return state;        
    }    
    
    public long getMaxCols() {    
        return maxCols;        
    }    
    
    public List<String> getSubscribedSessionIDs() {
        return subscribedSessionIDs;        
    }    
    

    public void setMaxPlayers(int maxPlayers) {    
        this.maxPlayers = maxPlayers;        
    }    
    
    public void setSeed(long seed) {    
        this.seed = seed;        
    }    
    
    public void setChunkIDs(ArrayList<String> chunkIDs) {
        this.chunkIDs = chunkIDs;        
    }    
    
    public void setOwnerID(String ownerID) {    
        this.ownerID = ownerID;        
    }    
    
    public void setCreatedOn(long createdOn) {    
        this.createdOn = createdOn;        
    }    
    
    public void setDifficulty(Difficulty difficulty) {    
        this.difficulty = difficulty;        
    }    
    
    public void setMaxRows(long maxRows) {    
        this.maxRows = maxRows;        
    }    
    
    public void setHeightLimit(int heightLimit) {    
        this.heightLimit = heightLimit;        
    }    
    
    public void setName(String name) {    
        this.name = name;        
    }    
    
    public void setId(String id) {    
        this.id = id;        
    }    
    
    public void setState(GameState state) {    
        this.state = state;        
    }    
    
    public void setMaxCols(long maxCols) {    
        this.maxCols = maxCols;        
    }    
    
    public void setSubscribedSessionIDs(ArrayList<String> subscribedSessionIDs) {
        this.subscribedSessionIDs = subscribedSessionIDs;        
    }    
    

    @Override    
    public MAWorldProto.Builder toProto() {
        MAWorldProto.Builder protoBuilder = MAWorldProto.newBuilder();
        protoBuilder.setMaxPlayers(maxPlayers);        
        protoBuilder.setSeed(seed);        
        protoBuilder.addAllChunkIDs(chunkIDs);        
        protoBuilder.setOwnerID(ownerID);        
        protoBuilder.setCreatedOn(createdOn);        
        protoBuilder.setDifficulty(difficulty);        
        protoBuilder.setMaxRows(maxRows);        
        protoBuilder.setHeightLimit(heightLimit);        
        protoBuilder.setName(name);        
        protoBuilder.setId(id);        
        protoBuilder.setState(state);        
        protoBuilder.setMaxCols(maxCols);        
        protoBuilder.addAllSubscribedSessionIDs(subscribedSessionIDs);        
        return protoBuilder;        
    }    
    
    public final boolean cellIsInBounds(int cellRow, int cellCol) {

        Long maxCellRow = null;
        Long minCellRow = null;
        Long maxCellCol = null;
        Long minCellCol = null;

        if (maxCols >= 1) {
            if (maxCols % 2 == 0) {
                maxCellCol = maxCols / 2;
                minCellCol = -maxCols / 2 + 1;
            }
            else {
                maxCellCol = maxCols / 2;
                minCellCol = -maxCols / 2;
            }
        }

        if (maxRows >= 1) {
            if (maxRows % 2 == 0) {
                maxCellRow = maxRows / 2;
                minCellRow = -maxRows / 2 + 1;
            }
            else {
                maxCellRow = maxRows / 2;
                minCellRow = -maxRows / 2;
            }
        }

        //Limited state initializes min and max for row and col:
        if (maxCellRow != null && maxCellCol != null && minCellRow != null && minCellCol != null) {
            return cellRow >= minCellRow && cellRow <= maxCellRow && cellCol >= minCellCol && cellCol <= maxCellCol;
        }
        //Unlimited state will not initialize any of these, return true because everything falls within bounds:
        else {
            return true;
        }
    }

    public final boolean cellIsInBounds(final MatrixPosition cellPosition) {
        return cellIsInBounds(cellPosition.getRow(), cellPosition.getCol());
    }

    public final boolean chunkIsInBounds(int chunkRow, int chunkCol) {
        final int startRow = MATerrainChunk.getChunkStartRowFromChunkRow(chunkRow);
        final int lastRow = MATerrainChunk.getChunkLastRowFromChunkRow(chunkRow);
        final int startCol = MATerrainChunk.getChunkStartColFromChunkCol(chunkCol);
        final int lastCol = MATerrainChunk.getChunkLastColFromChunkCol(chunkCol);
        for (int row = startRow; row <= lastRow; row++) {
            for (int col = startCol; col <= lastCol; col++) {
                if (cellIsInBounds(row, col)) {
                    return true;
                }
            }
        }
        return false;
    }

    public final boolean hasChunk(final String chunkID) {
        for (final String id : chunkIDs) {
            if (id.equals(chunkID)) {
                return true;
            }
        }
        return false;
    }
    public final void addChunk(final String chunkID) {
        if (!hasChunk(chunkID)) {
            this.chunkIDs.add(chunkID);
        }
    }


}
