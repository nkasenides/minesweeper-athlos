/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 16-11-2021 12:37:22
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package com.nkasenides.minesweeper.server.grpc;

import com.nkasenides.athlos.proto.Modifiable;
import com.nkasenides.minesweeper.model.*;
import com.nkasenides.minesweeper.persistence.DBManager;
import com.nkasenides.minesweeper.proto.MAServiceProtoGrpc;

import com.nkasenides.minesweeper.state.State;
import com.nkasenides.minesweeper.state.WorldContext;
import io.grpc.stub.StreamObserver;

import com.nkasenides.minesweeper.proto.*;

import com.nkasenides.minesweeper.auth.*;

import javax.activity.InvalidActivityException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.UUID;
import java.util.function.Consumer;


public class MAServiceImpl extends MAServiceProtoGrpc.MAServiceProtoImplBase {
    @Override    
    public void listGames(ListGamesRequest request, StreamObserver<ListGameResponse> responseObserver) {
        //NEW
        final Collection<MAWorld> worlds = DBManager.world.list();
        ListGameResponse.Builder response = ListGameResponse.newBuilder()
                .setStatus(ListGameResponse.Status.OK)
                .setMessage("GAMES_LISTED");

        worlds.forEach(maWorld -> response.addWorlds(maWorld.toProto().build()));
        responseObserver.onNext(response.build());
    }    
    
    @Override    
    public void startGame(StartGameRequest request, StreamObserver<StartGameResponse> responseObserver) {
        throw new RuntimeException("/game/start is not implemented");
        //NOT NEEDED
    }    
    
    @Override    
    public void move(MoveRequest request, StreamObserver<MoveResponse> responseObserver) {
        final MAWorldSession worldSession = DBManager.worldSession.get(request.getWorldSessionID());
        if (worldSession == null) {
            MoveResponse response = MoveResponse.newBuilder()
                    .setStatus(MoveResponse.Status.INVALID_WORLD_SESSION_ID)
                    .setMessage("INVALID_WORLD_SESSION_ID")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        final MAWorld world = DBManager.world.get(worldSession.getWorldID());
        if (world == null) {
            MoveResponse response = MoveResponse.newBuilder()
                    .setStatus(MoveResponse.Status.INVALID_WORLD_SESSION_ID)
                    .setMessage("INVALID_WORLD")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        final MatrixPositionProto movePosition = request.getMovePosition();
        if (movePosition.getRow() >= world.getMaxRows()) {
            MoveResponse response = MoveResponse.newBuilder()
                    .setStatus(MoveResponse.Status.INVALID_MOVE)
                    .setMessage("INVALID_MOVE_ROW")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        if (movePosition.getCol() >= world.getMaxCols()) {
            MoveResponse response = MoveResponse.newBuilder()
                    .setStatus(MoveResponse.Status.INVALID_MOVE)
                    .setMessage("INVALID_MOVE_COL")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        worldSession.setCameraPosition(movePosition.toObject());
        DBManager.worldSession.update(worldSession);

        final MAPartialStateProto partialStateSnapshot = State.forWorld(world.getId()).getPartialStateSnapshot(worldSession);

        MoveResponse response = MoveResponse.newBuilder()
                .setStatus(MoveResponse.Status.OK)
                .setMessage("OK")
                .setPartialState(partialStateSnapshot)
                .build();
        responseObserver.onNext(response);
    }
    
    @Override    
    public void createGame(CreateGameRequest request, StreamObserver<CreateGameResponse> responseObserver) {
        //NEW
        if (request.getMaxPlayers() < 1) {
            CreateGameResponse response = CreateGameResponse.newBuilder()
                    .setStatus(CreateGameResponse.Status.INVALID_GAME_SIZE)
                    .setMessage("INVALID_MAX_PLAYERS")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        if (request.getWidth() < 5) {
            CreateGameResponse response = CreateGameResponse.newBuilder()
                    .setStatus(CreateGameResponse.Status.INVALID_GAME_SIZE)
                    .setMessage("INVALID_WIDTH")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        if (request.getHeight() < 5) {
            CreateGameResponse response = CreateGameResponse.newBuilder()
                    .setStatus(CreateGameResponse.Status.INVALID_GAME_SIZE)
                    .setMessage("INVALID_HEIGHT")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        String worldID = UUID.randomUUID().toString();

        MAWorld world = new MAWorld();
        world.setId(worldID);
        world.setCreatedOn(System.currentTimeMillis());
        world.setDifficulty(request.getDifficulty());
        world.setChunkIDs(new ArrayList<>());
        world.setHeightLimit(0);
        world.setMaxCols(request.getWidth());
        world.setMaxRows(request.getHeight());
        world.setName(worldID);
        world.setMaxPlayers(request.getMaxPlayers());
        world.setOwnerID("");
        world.setSeed(0);
        world.setSubscribedSessionIDs(new ArrayList<>());
        DBManager.world.create(world);

        CreateGameResponse response = CreateGameResponse.newBuilder()
                .setStatus(CreateGameResponse.Status.OK)
                .setMessage("OK")
                .build();
        responseObserver.onNext(response);

    }    
    
    @Override    
    public void getState(GetStateRequest request, StreamObserver<GetStateResponse> responseObserver) {
        final MAWorldSession worldSession = DBManager.worldSession.get(request.getWorldSessionID());
        if (worldSession == null) {
            GetStateResponse response = GetStateResponse.newBuilder()
                    .setStatus(GetStateResponse.Status.NO_SUCH_WORLD_SESSION)
                    .setMessage("NO_SUCH_WORLD_SESSION")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        final MAWorld world = DBManager.world.get(worldSession.getWorldID());
        if (world == null) {
            GetStateResponse response = GetStateResponse.newBuilder()
                    .setStatus(GetStateResponse.Status.NO_SUCH_WORLD_SESSION)
                    .setMessage("INVALID_WORLD")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        final MAPartialStateProto partialStateSnapshot = State.forWorld(world.getId()).getPartialStateSnapshot(worldSession);

        GetStateResponse response = GetStateResponse.newBuilder()
                .setStatus(GetStateResponse.Status.OK)
                .setMessage("OK")
                .setPartialState(partialStateSnapshot)
                .build();
        responseObserver.onNext(response);
    }    
    
    @Override    
    public void subscribe(SubscribeRequest request, StreamObserver<SubscribeResponse> responseObserver) {    
        super.subscribe(request, responseObserver);
        //TODO - Implement this service.
    }    
    
    @Override    
    public void joinGame(JoinGameRequest request, StreamObserver<JoinGameResponse> responseObserver) {
        //NEW

        //Check game session:
        final MAGameSession gameSession = DBManager.gameSession.get(request.getGameSessionID());
        if (gameSession == null) {
            final JoinGameResponse response = JoinGameResponse.newBuilder()
                    .setStatus(JoinGameResponse.Status.INVALID_GAME_SESSION_ID)
                    .setMessage("INVALID_GAME_SESSION_ID")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        //Check world:
        final MAWorld world = DBManager.world.get(request.getGameID());
        if (world == null) {
            final JoinGameResponse response = JoinGameResponse.newBuilder()
                    .setStatus(JoinGameResponse.Status.CANNOT_JOIN)
                    .setMessage("CANNOT_FIND_WORLD")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        final PartialStatePreferenceProto partialStatePreference = request.getPartialStatePreference();

        //Check max players:
        final Collection<MAWorldSession> worldSessionsForWorld = DBManager.worldSession.listForWorld(world.getId());
        if (worldSessionsForWorld.size() >= world.getMaxPlayers()) {
            final JoinGameResponse response = JoinGameResponse.newBuilder()
                    .setStatus(JoinGameResponse.Status.CANNOT_JOIN)
                    .setMessage("MAX_PLAYERS_REACHED")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        MAWorldSession playerWorldSession = DBManager.worldSession.getForPlayerAndWorld(gameSession.getPlayerID(), world.getId());
        if (playerWorldSession != null) {
            final JoinGameResponse response = JoinGameResponse.newBuilder()
                    .setStatus(JoinGameResponse.Status.OK)
                    .setMessage("OK")
                    .setWorldSession(playerWorldSession.toProto().build())
                    .build();
            responseObserver.onNext(response);
        }
        else {
            final MAPlayer player = DBManager.player.get(gameSession.getPlayerID());

            playerWorldSession = new MAWorldSession();
            playerWorldSession.setId(UUID.randomUUID().toString());
            playerWorldSession.setWorldID(world.getId());
            playerWorldSession.setPlayerID(gameSession.getPlayerID());
            playerWorldSession.setPlayerName(player.getName());
            playerWorldSession.setCameraPosition(new MatrixPosition(0, 0));
            playerWorldSession.setCreatedOn(System.currentTimeMillis());
            playerWorldSession.setExpiresOn(System.currentTimeMillis() + 3600 * 24 * 5);
            playerWorldSession.setIpAddress("");
            playerWorldSession.setPoints(0);
            playerWorldSession.setPartialStatePreference(partialStatePreference.toObject());
            DBManager.worldSession.create(playerWorldSession);

            final JoinGameResponse response = JoinGameResponse.newBuilder()
                    .setStatus(JoinGameResponse.Status.OK)
                    .setMessage("OK")
                    .setWorldSession(playerWorldSession.toProto().build())
                    .build();
            responseObserver.onNext(response);

        }
    }
    
    @Override    
    public void flag(FlagRequest request, StreamObserver<RevealResponse> responseObserver) {    
        super.flag(request, responseObserver);        
        //TODO - Implement this service.        
    }    
    
    @Override    
    public void reveal(RevealRequest request, StreamObserver<RevealResponse> responseObserver) {

        final MAWorldSession worldSession = DBManager.worldSession.get(request.getWorldSessionID());
        if (worldSession == null) {
            RevealResponse response = RevealResponse.newBuilder()
                    .setStatus(RevealResponse.Status.INVALID_WORLD_SESSION_ID)
                    .setMessage("NO_SUCH_WORLD_SESSION")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        final MAWorld world = DBManager.world.get(worldSession.getWorldID());
        if (world == null) {
            RevealResponse response = RevealResponse.newBuilder()
                    .setStatus(RevealResponse.Status.INVALID_GAME)
                    .setMessage("INVALID_GAME")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        if (request.getPosition().getRow() >= world.getMaxRows()) {
            RevealResponse response = RevealResponse.newBuilder()
                    .setStatus(RevealResponse.Status.OTHER_ERROR)
                    .setMessage("INVALID_POSITION_ROW")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        if (request.getPosition().getCol() >= world.getMaxCols()) {
            RevealResponse response = RevealResponse.newBuilder()
                    .setStatus(RevealResponse.Status.OTHER_ERROR)
                    .setMessage("INVALID_POSITION_COL")
                    .build();
            responseObserver.onNext(response);
            return;
        }

        final Map<String, MATerrainCellProto> terrain = State.forWorld(world.getId()).getTerrain(request.getPosition().toObject(), 16);
        final MATerrainCell cell = terrain.get(request.getPosition().toHash()).toObject();

        if (cell.getRevealState() != RevealState.COVERED_RevealState) {
            if (request.getPosition().getCol() >= world.getMaxCols()) {
                RevealResponse response = RevealResponse.newBuilder()
                        .setStatus(RevealResponse.Status.CELL_ALREADY_REVEALED)
                        .setMessage("CELL_ALREADY_REVEALED")
                        .build();
                responseObserver.onNext(response);
                return;
            }
        }

        if (cell.isIsMined()) {
            cell.setRevealState(RevealState.REVEALED_MINE_RevealState);
            //TODO - Create and call computeGameState()
        }
        else {
            //TODO...
        }

    }    
    
}

